import numpy as np
import matplotlib.pyplot as plt
from numba import njit


@njit
def golomb_grow(n: int) -> np.ndarray:
    """
    Generates the first n Golomb rulers using an optimized growing algorithm.
    """
    G = np.zeros(n, dtype=np.int64)
    # D will store whether a difference has been seen. Use a larger initial size.
    D_size = 1024 
    D = np.zeros(D_size, dtype=np.bool_)

    G[0] = 0
    current_length = 1

    while current_length < n:
        m = G[current_length - 1] + 1  # Start checking from the next integer after the last element

        while True:
            valid = True
            max_diff = 0

            # Check if current m creates any repeated differences with existing G elements
            for i in range(current_length):
                diff = m - G[i]
                
                # Dynamically resize D if a new difference exceeds its current bounds
                if diff >= D_size:
                    new_size = max(D_size * 2, diff + 1) # Double size or just enough + 1
                    new_D = np.zeros(new_size, dtype=np.bool_)
                    new_D[:D_size] = D # Copy old values
                    D = new_D
                    D_size = new_size

                if D[diff]: # If this difference already exists
                    valid = False
                    break
                if diff > max_diff:
                    max_diff = diff

            if valid:
                # Secondary check using a temporary array for differences generated by *this* m.
                # This ensures that m itself doesn't create internal duplicates among its *new* differences.
                # Example: If G = [0, 1] and m = 2, then diffs are (2-0)=2, (2-1)=1. No conflict.
                # If G = [0, 2] and m = 4, then diffs are (4-0)=4, (4-2)=2. Conflict if 2 already in G, or if 2 was a diff already
                # (This part of the algorithm logic is a bit complex and might need further study if not already understood fully)
                temp = np.zeros(max_diff + 1, dtype=np.bool_)
                for i in range(current_length):
                    diff = m - G[i]
                    if temp[diff]: # Check for duplicates among the *new* differences formed by m
                        valid = False
                        break
                    temp[diff] = True

            if valid:
                # If m is valid, add its new differences to the global D set
                for i in range(current_length):
                    diff = m - G[i]
                    D[diff] = True
                G[current_length] = m  # Add m to the Golomb ruler
                current_length += 1
                break  # Move to find the next element in the ruler
            else:
                m += 1  # Increment m and try again

    return G


@njit
def create_signal_from_golomb(G: np.ndarray, remove_dc: bool) -> np.ndarray:
    """
    Creates a binary signal from a Golomb ruler, with optional DC removal.
    The signal length is G[-1] + 1, and 1s are placed at Golomb indices.
    """
    signal = np.zeros(G[-1] + 1)
    signal[G] = 1
    if remove_dc:
        signal -= np.mean(signal)  # Remove DC component (mean subtraction)
    
    # Normalize by the maximum absolute value to keep amplitude within [-1, 1]
    # This is applied whether DC is removed or not, affecting overall amplitude scaling.
    max_amp = np.max(np.abs(signal))
    if max_amp > 1e-10: # Avoid division by zero if signal is all zeros (unlikely here)
        signal /= max_amp
    
    return signal


def compute_spectrum(signal: np.ndarray):
    """
    Computes the FFT, magnitude spectrum, and power spectrum of a signal.
    Includes print statements for DC components for debugging.
    """
    # --- DEBUGGING PRINT STATEMENTS ---
    print(f"Value of signal mean BEFORE FFT: {np.mean(signal)}")
    
    X = np.fft.fft(signal)
    freqs = np.fft.fftfreq(len(X))
    mag = np.abs(X)
    power = mag ** 2
    
    print(f"Magnitude of DC component (mag[0]): {mag[0]}")
    print(f"Power of DC component (power[0]): {power[0]}")
    # --- END DEBUGGING PRINT STATEMENTS ---
    
    return freqs, mag, power


# Added 'remove_dc_flag' parameter to control frequency indexing for plotting
def plot_results(signal: np.ndarray, freqs: np.ndarray, mag: np.ndarray, power: np.ndarray, n: int, remove_dc_flag: bool):
    """
    Plots the time-domain signal, FFT magnitude spectrum, and power spectrum.
    Conditionally excludes DC component from frequency plots if it was removed.
    """
    
    # Conditional indexing for frequencies based on remove_dc_flag
    if remove_dc_flag:
        # If DC was removed, exclude 0 Hz (DC) from the plot for cleaner visualization
        idx = (freqs > 0) & (freqs <= 0.5)
    else:
        # If DC was NOT removed, include 0 Hz (DC) in the plot
        idx = (freqs >= 0) & (freqs <= 0.5)

    # Apply the index to filter frequencies and their corresponding magnitudes/powers
    freqs = freqs[idx]
    mag = mag[idx]
    power = power[idx]

    fig, axes = plt.subplots(1, 3, figsize=(18, 5))

    time_indices = np.arange(len(signal))

    # --- Time-domain stem plot ---                                 
    # Plot positive values in blue
    pos_idx = signal >= 0
    axes[0].stem(time_indices[pos_idx], signal[pos_idx],
                 basefmt=" ", linefmt='b-', markerfmt='bo')

    # Plot negative values in red (only if they exist)
    neg_idx = signal < 0
    if np.any(neg_idx):
        axes[0].stem(time_indices[neg_idx], signal[neg_idx],
                     basefmt=" ", linefmt='r-', markerfmt='ro')

    axes[0].set_xscale("log") # Logarithmic scale for time index often good for sparse signals
    axes[0].set_title(f"Golomb Signal (n = {n}) - Time Domain")
    axes[0].set_xlabel("Time Index")
    axes[0].set_ylabel("Amplitude")
    axes[0].grid(True)

    # --- FFT Magnitude Spectrum Plot ---
    axes[1].plot(freqs, mag, color='blue') # Line plot for continuous spectrum feel
    axes[1].set_title("FFT Magnitude Spectrum")
    axes[1].set_xlabel("Frequency (Normalized)")
    axes[1].set_ylabel("Magnitude")
    axes[1].grid(True)
    axes[1].set_xlim(0, 0.5) # Limit X-axis to positive frequencies up to Nyquist
    # Optional: Add stem plot for clarity of individual bins (can get cluttered)
    # axes[1].stem(freqs, mag, basefmt=" ", linefmt='none', markerfmt='bo', use_line_collection=True)
    # axes[1].set_yscale("log") # Uncomment for log scale on Magnitude, if desired

    # --- Power Spectrum Plot (Log Scale) ---
    axes[2].semilogy(freqs, power, color='blue') # semilogy sets y-axis to logarithmic
    axes[2].set_title("Power Spectrum (log scale)")
    axes[2].set_xlabel("Frequency (Normalized)")
    axes[2].set_ylabel("Power")
    axes[2].grid(True)
    axes[2].set_xlim(0, 0.5) # Limit X-axis to positive frequencies up to Nyquist
    # Optional: Add stem plot for clarity of individual bins
    # axes[2].stem(freqs, power, basefmt=" ", linefmt='none', markerfmt='go', use_line_collection=True)

    plt.tight_layout() # Adjust subplot params for a tight layout
    plt.show()


def main(n: int, DC: bool = False):
    """
    Main function to generate Golomb ruler, create signal, compute spectrum, and plot results.
    DC=False implies remove_dc=True (DC component will be removed from signal).
    DC=True implies remove_dc=False (DC component will be kept in signal).
    """
    remove_dc_flag = not DC  # Determine whether to remove DC based on the DC parameter

    G = golomb_grow(n)                                              
    signal = create_signal_from_golomb(G, remove_dc=remove_dc_flag)
    freqs, mag, power = compute_spectrum(signal)
    
    # Pass the remove_dc_flag to plot_results to control conditional plotting
    plot_results(signal, freqs, mag, power, n, remove_dc_flag)


# --- Execute the main function ---
if __name__ == "__main__":
    print("--- Running with DC component REMOVED (DC=False) ---")
    main(n=300, DC=False) # This will set remove_dc_flag=True, excluding 0Hz from frequency plots.
    print("\n--- Running with DC component KEPT (DC=True) ---")
    main(n=300, DC=True)  # This will set remove_dc_flag=False, including 0Hz in frequency plots.

